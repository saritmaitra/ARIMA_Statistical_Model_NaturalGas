# -*- coding: utf-8 -*-
"""Natural Gas & ARIMA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e0i4ie8rkLv10XVypJp7LnydoaClDF1y
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from pandas import DataFrame 
import seaborn as sns
from pylab import rcParams
import matplotlib.pyplot as plt
from matplotlib import rc
from pandas.plotting import register_matplotlib_converters
import pandas_datareader as web
!pip install plotly
import plotly.graph_objects as go

# %matplotlib inline
# %config InlineBackend.figure_format='retina'

register_matplotlib_converters()
sns.set(style='whitegrid', palette='muted', font_scale=1.5)

rcParams['figure.figsize'] = 22, 10

RANDOM_SEED = 42

np.random.seed(RANDOM_SEED)
from scipy import stats
from sklearn.preprocessing import MinMaxScaler

from statsmodels.tsa.seasonal import seasonal_decompose

print("....Data Loading...."); print();
print('\033[4mHenry Hub Natural Gas Price\033[0m');
data = web.DataReader('NNJ24.NYM', data_source = 'yahoo', start = '2000-01-01')
data.rename(columns={'Close': 'price'}, inplace=True)
df = data.resample('M').last()
df = DataFrame(df.price.copy())
df

window = 12
df['rolling_mean'] = df.price.rolling(window=window).mean()
df['rolling_std'] = df.price.rolling(window=window).std()
df.plot(title='Natural Gas Price', figsize = (10,5))
plt.show()

decomp = seasonal_decompose(df.price, model='multiplicative')
rcParams['figure.figsize'] = 10, 6
decomp.plot().suptitle('Multiplicative Decomposition', fontsize=14);

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller, kpss

print('Results Dickey-Fuller Test:')
test = adfuller(df.price, autolag = 'AIC')
output = pd.Series(test[0:4], index = ['Test Statistic', 'p-value','# of Lags Used', '# of Observations Used'])
for key, value in test[4].items():
    output[f'Critical Value ({key})'] = value

print(output)

def kpss_test(x, h0_type='c'):
  indices = ['Test Statistic', 'p-value', '# of Lags']
  kpss_test = kpss(x, regression=h0_type)
  results = pd.Series(kpss_test[0:3], index=indices)
  for key, value in kpss_test[3].items():
    results[f'Critical Value ({key})'] = value
  return results

kpss_test(df.price)

lags = 40
sig_level = 0.05
fig, ax = plt.subplots(2, 1)
plot_acf(df.price, ax=ax[0], lags=N_LAGS, alpha=SIGNIFICANCE_LEVEL)
plot_pacf(df.price, ax=ax[1], lags=N_LAGS, alpha=SIGNIFICANCE_LEVEL)
plt.tight_layout()

price_diff = df.price.diff().dropna()
fig, ax = plt.subplots(2, sharex=True)
df.price.plot(title = "Natural Gas price", ax=ax[0])
price_diff.plot(ax=ax[1], title='First Differences')
plt.show()

fig, ax = plt.subplots(2, 1)
plot_acf(price_diff, ax=ax[0], lags=lags, alpha=sig_level)
plot_pacf(price_diff, ax=ax[1], lags=N_LAGS, alpha=sig_level)
plt.tight_layout()

print(adf_test(price_diff).dropna()); print(); print(kpss_test(price_diff).dropna());

rcParams['figure.figsize'] = 10, 6
columns = ['price_diff', 'rolling_mean_diff', 'rolling_std_diff']
df['price_diff'] = df['price'].diff()
df['rolling_mean_diff'] = df['price'].diff().rolling(window=window).mean()
df['rolling_std_diff'] = df['price'].diff().rolling(window=window).std()
df[columns].plot(title='Crude Oil differenced Price')
plt.show()

from statsmodels.tsa.stattools import acf, pacf
rcParams['figure.figsize'] = 10, 5

diff = df.price.diff().dropna()

lag_acf = acf(diff, nlags=20)
lag_pacf = pacf(diff, nlags=20, method = 'ols')

# plot acf
plt.subplot(121); plt.plot(lag_acf);
plt.axhline(y=1, linestyle='--', color = 'gray')
plt.axhline(y=-1.96/np.sqrt(len(diff)), linestyle='--', color = 'gray')
plt.axhline(y=1.96/np.sqrt(len(diff)), linestyle='--', color = 'gray')
plt.title('Auto correlation function')

# plot pacf
plt.subplot(122); plt.plot(lag_pacf);
plt.axhline(y=1, linestyle='--', color = 'gray')
plt.axhline(y=-1.96/np.sqrt(len(diff)), linestyle='--', color = 'gray')
plt.axhline(y=1.96/np.sqrt(len(diff)), linestyle='--', color = 'gray')
plt.title('Partial Auto correlation function'); plt.tight_layout();

from statsmodels.tsa.arima_model import ARIMA
arima = ARIMA(df.price, order=(3, 1, 2)).fit(disp=0)
arima.summary()

import scipy.stats as scs
import statsmodels.api as sm

def arima_diagnostics(resids, n_lags=40):
  fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
  r = resids
  resids = (r - np.nanmean(r)) / np.nanstd(r)
  resids_nonmissing = resids[~(np.isnan(resids))]
  
  sns.lineplot(x=np.arange(len(resids)), y=resids, ax=ax1)
  ax1.set_title('Standardized residuals')
 
  x_lim = (-1.96 * 2, 1.96 * 2)
  r_range = np.linspace(x_lim[0], x_lim[1])
  norm_pdf = scs.norm.pdf(r_range)
  sns.distplot(resids_nonmissing, hist=True, kde=True, norm_hist=True, ax=ax2)
  ax2.plot(r_range, norm_pdf, 'g', lw=2, label='N(0,1)')
  ax2.set_title('Distribution of standardized residuals')
  ax2.set_xlim(x_lim)
  ax2.legend()
  
  # Q-Q plot
  qq = sm.qqplot(resids_nonmissing, line='s', ax=ax3)
  ax3.set_title('Q-Q plot')
  
  # ACF plot
  plot_acf(resids, ax=ax4, lags=n_lags, alpha=0.05)
  ax4.set_title('ACF plot')
  return fig

arima_diagnostics(arima.resid, 40)
plt.tight_layout()

from statsmodels.stats.diagnostic import acorr_ljungbox

ljung_box_results = acorr_ljungbox(arima.resid)
fig, ax = plt.subplots(1, figsize=[10, 5])
sns.scatterplot(x=range(len(ljung_box_results[1])), y=ljung_box_results[1], ax=ax)
ax.axhline(0.05, ls='--', c='r')
ax.set(title="Ljung-Box test's results", xlabel='Lag', ylabel='p-value')
plt.show()

from pandas import DataFrame, concat

forecast = int(12)
arima_pred, std, ci = (arima.forecast(forecast))

arima_pred = DataFrame(arima_pred)
d = DataFrame(df.price.tail(len(arima_pred))); d.reset_index(inplace = True)
d = d.append(DataFrame({'Date': pd.date_range(start = d.Date.iloc[-1], 
                                             periods = (len(d)+1), freq = 'm', closed = 'right')}))
d = d.tail(forecast); d.set_index('Date', inplace = True)
arima_pred.index = d.index
arima_pred.rename(columns = {0: 'arima_fcast'}, inplace=True)

# 95% prediction interval
ci = DataFrame(ci)
ci.rename(columns = {0: 'lower95', 1:'upper95'}, inplace=True)
ci.index = arima_pred.index

ARIMA = concat([arima_pred, ci], axis=1)
ARIMA

pip install pmdarima

import pmdarima as pm

model = pm.auto_arima(df.price, error_action='ignore', suppress_warnings=True,
                      seasonal=False)
model.summary()

model = pm.auto_arima(df.price, error_action='ignore', suppress_warnings=True,
                      seasonal=False, stepwise=False, approximation=False, n_jobs=-1)
model.summary()

auto_arima_pred = model.predict(n_periods=forecast, return_conf_int=True,alpha=0.05)
auto_arima_pred = [DataFrame(auto_arima_pred[0],columns=['prediction']),DataFrame(auto_arima_pred[1], 
                                                                                  columns=['ci_lower', 'ci_upper'])]
auto_arima_pred = concat(auto_arima_pred,axis=1).set_index(ARIMA.index)
auto_arima_pred

plt.set_cmap('cubehelix'); sns.set_palette('cubehelix')
COLORS = [plt.cm.cubehelix(x) for x in [0.1, 0.3, 0.5, 0.7]]; fig, ax = plt.subplots(1)
ax = sns.lineplot(data=df.price, color=COLORS[0], label='Actual')
ax.plot(ARIMA.arima_fcast, c=COLORS[1], label='ARIMA(2,1,1)')
ax.fill_between(ARIMA.index, ARIMA.lower95, ARIMA.upper95, alpha=0.3, facecolor=COLORS[1])
ax.plot(auto_arima_pred.prediction, c=COLORS[2], label='ARIMA(0,1,0)')
ax.fill_between(auto_arima_pred.index, auto_arima_pred.ci_lower, auto_arima_pred.ci_upper,
                alpha=0.2, facecolor=COLORS[2])
ax.set(title="Natural Gas price - historical and forecast", xlabel='Date', ylabel='Price ($)') 
ax.legend(loc='best')